<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Python 多线程编程 | My Blog</title><meta name=keywords content><meta name=description content='基本概念
多任务中的并发和并行

并发: 一段时间内交替执行任务
并行: 一段时间内同时执行多个任务

进程
python 中可以通过多进程来实现多任务.
进程的概念
进程 (Process) 是操作系统资源分配和调度的基本单位.
# main.py

def foo1():...

def foo2():...

foo1()
foo2()
在运行 .py 文件时, 操作系统会创建一个进程, 依次运行 foo1 和 foo2 两个方法.
多进程
main.py 运行后会创建一个进程, 此时如果再次创建一个进程, 即为子进程. 我们让主进程运行 foo1, 让子进程来运行 foo2即可提升代码运行的效率.
进程的创建步骤
1.导入进程包
import multiprocessing
2.创建进程对象
mp = multiprocessing.Process()
Process() 方法主要有3个参数:

target: 执行的目标函数名(方法名), 如 foo2
name: 进程名, 一般不用设置
group: 进程组, 当前为 None

3.启动进程
mp.start()
进程执行带有参数的任务

args 以元组方式传参
kwargs 以字典方式传参

def foo1(argument:int):...
def foo2(argument:int):...

foo1_process = multiprocessing.Process(target=foo1, args=(3,))
foo1_process.start()

foo2_process = multiprocessing.Process(target=foo2, kwargs={"argument", 3})
foo2_process.start()
获取进程编号
当程序进程数量越来越多时, 为了更好地对进程进行管理, 就需要知道每个进程的编号'><meta name=author content><link rel=canonical href=https://iuwu98005.github.io/posts/250626-python-thread/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://iuwu98005.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://iuwu98005.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://iuwu98005.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://iuwu98005.github.io/apple-touch-icon.png><link rel=mask-icon href=https://iuwu98005.github.io/safari-pinned-tab.svg><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#ffffff"><link rel=alternate hreflang=en href=https://iuwu98005.github.io/posts/250626-python-thread/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://iuwu98005.github.io/posts/250626-python-thread/"><meta property="og:site_name" content="My Blog"><meta property="og:title" content="Python 多线程编程"><meta property="og:description" content='基本概念 多任务中的并发和并行
并发: 一段时间内交替执行任务 并行: 一段时间内同时执行多个任务 进程 python 中可以通过多进程来实现多任务.
进程的概念 进程 (Process) 是操作系统资源分配和调度的基本单位.
# main.py def foo1():... def foo2():... foo1() foo2() 在运行 .py 文件时, 操作系统会创建一个进程, 依次运行 foo1 和 foo2 两个方法.
多进程 main.py 运行后会创建一个进程, 此时如果再次创建一个进程, 即为子进程. 我们让主进程运行 foo1, 让子进程来运行 foo2即可提升代码运行的效率.
进程的创建步骤 1.导入进程包
import multiprocessing 2.创建进程对象
mp = multiprocessing.Process() Process() 方法主要有3个参数:
target: 执行的目标函数名(方法名), 如 foo2 name: 进程名, 一般不用设置 group: 进程组, 当前为 None 3.启动进程
mp.start() 进程执行带有参数的任务 args 以元组方式传参 kwargs 以字典方式传参 def foo1(argument:int):... def foo2(argument:int):... foo1_process = multiprocessing.Process(target=foo1, args=(3,)) foo1_process.start() foo2_process = multiprocessing.Process(target=foo2, kwargs={"argument", 3}) foo2_process.start() 获取进程编号 当程序进程数量越来越多时, 为了更好地对进程进行管理, 就需要知道每个进程的编号'><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-06-26T14:36:07+08:00"><meta property="article:modified_time" content="2025-06-26T14:36:07+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Python 多线程编程"><meta name=twitter:description content='基本概念
多任务中的并发和并行

并发: 一段时间内交替执行任务
并行: 一段时间内同时执行多个任务

进程
python 中可以通过多进程来实现多任务.
进程的概念
进程 (Process) 是操作系统资源分配和调度的基本单位.
# main.py

def foo1():...

def foo2():...

foo1()
foo2()
在运行 .py 文件时, 操作系统会创建一个进程, 依次运行 foo1 和 foo2 两个方法.
多进程
main.py 运行后会创建一个进程, 此时如果再次创建一个进程, 即为子进程. 我们让主进程运行 foo1, 让子进程来运行 foo2即可提升代码运行的效率.
进程的创建步骤
1.导入进程包
import multiprocessing
2.创建进程对象
mp = multiprocessing.Process()
Process() 方法主要有3个参数:

target: 执行的目标函数名(方法名), 如 foo2
name: 进程名, 一般不用设置
group: 进程组, 当前为 None

3.启动进程
mp.start()
进程执行带有参数的任务

args 以元组方式传参
kwargs 以字典方式传参

def foo1(argument:int):...
def foo2(argument:int):...

foo1_process = multiprocessing.Process(target=foo1, args=(3,))
foo1_process.start()

foo2_process = multiprocessing.Process(target=foo2, kwargs={"argument", 3})
foo2_process.start()
获取进程编号
当程序进程数量越来越多时, 为了更好地对进程进行管理, 就需要知道每个进程的编号'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://iuwu98005.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Python 多线程编程","item":"https://iuwu98005.github.io/posts/250626-python-thread/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Python 多线程编程","name":"Python 多线程编程","description":"基本概念 多任务中的并发和并行\n并发: 一段时间内交替执行任务 并行: 一段时间内同时执行多个任务 进程 python 中可以通过多进程来实现多任务.\n进程的概念 进程 (Process) 是操作系统资源分配和调度的基本单位.\n# main.py def foo1():... def foo2():... foo1() foo2() 在运行 .py 文件时, 操作系统会创建一个进程, 依次运行 foo1 和 foo2 两个方法.\n多进程 main.py 运行后会创建一个进程, 此时如果再次创建一个进程, 即为子进程. 我们让主进程运行 foo1, 让子进程来运行 foo2即可提升代码运行的效率.\n进程的创建步骤 1.导入进程包\nimport multiprocessing 2.创建进程对象\nmp = multiprocessing.Process() Process() 方法主要有3个参数:\ntarget: 执行的目标函数名(方法名), 如 foo2 name: 进程名, 一般不用设置 group: 进程组, 当前为 None 3.启动进程\nmp.start() 进程执行带有参数的任务 args 以元组方式传参 kwargs 以字典方式传参 def foo1(argument:int):... def foo2(argument:int):... foo1_process = multiprocessing.Process(target=foo1, args=(3,)) foo1_process.start() foo2_process = multiprocessing.Process(target=foo2, kwargs={\u0026#34;argument\u0026#34;, 3}) foo2_process.start() 获取进程编号 当程序进程数量越来越多时, 为了更好地对进程进行管理, 就需要知道每个进程的编号\n","keywords":[],"articleBody":"基本概念 多任务中的并发和并行\n并发: 一段时间内交替执行任务 并行: 一段时间内同时执行多个任务 进程 python 中可以通过多进程来实现多任务.\n进程的概念 进程 (Process) 是操作系统资源分配和调度的基本单位.\n# main.py def foo1():... def foo2():... foo1() foo2() 在运行 .py 文件时, 操作系统会创建一个进程, 依次运行 foo1 和 foo2 两个方法.\n多进程 main.py 运行后会创建一个进程, 此时如果再次创建一个进程, 即为子进程. 我们让主进程运行 foo1, 让子进程来运行 foo2即可提升代码运行的效率.\n进程的创建步骤 1.导入进程包\nimport multiprocessing 2.创建进程对象\nmp = multiprocessing.Process() Process() 方法主要有3个参数:\ntarget: 执行的目标函数名(方法名), 如 foo2 name: 进程名, 一般不用设置 group: 进程组, 当前为 None 3.启动进程\nmp.start() 进程执行带有参数的任务 args 以元组方式传参 kwargs 以字典方式传参 def foo1(argument:int):... def foo2(argument:int):... foo1_process = multiprocessing.Process(target=foo1, args=(3,)) foo1_process.start() foo2_process = multiprocessing.Process(target=foo2, kwargs={\"argument\", 3}) foo2_process.start() 获取进程编号 当程序进程数量越来越多时, 为了更好地对进程进行管理, 就需要知道每个进程的编号\n获取当前进程编号\nimport os os.getpid() 获取当前父进程编号\nimport os os.getppid() 在方法运行后获取 pid:\ndef foo1(argument:int): # func print(f\"foo1 pid: {os.getpid()}\") def foo2(argument:int): # func print(f\"foo2 pid: {os.getpid()}\") if __name__ == \"__main__\": # 1. 创建子进程对象并指定任务名 foo1_process = multiprocessing.Process(target=foo1, args=(3,)) foo2_process = multiprocessing.Process(target=foo2, kwargs={\"argument\", 3}) # 2. 启动子进程并执行任务 foo1_process.start() foo2_process.start() 进程的注意点 主进程会等待所有子进程执行完成结束再结束.\ndef foo1(): for i in range(10): print(\"子进程运行中...\") time.sleep(0.2) print(\"子进程执行完毕\") if __name__ == \"__main__\": ps = multiprocessing.Process(target=foo1) ps.start() time.sleep(0.5) print(\"主进程执行完毕\") 如何实现主进程结束, 所有子进程也结束 设置守护主进程: ps.daemon = True\ndef foo1(): for i in range(10): print(\"子进程运行中...\") time.sleep(0.2) print(\"子进程执行完毕\") if __name__ == \"__main__\": ps = multiprocessing.Process(target=foo1) # 设置守护主进程, 主进程推出后子进程自动销毁, 不再执行子进程中的代码 ps.daemon = True ps.start() time.sleep(0.5) print(\"主进程执行完毕\") 结合实际案例 如何实现多进程实现拷贝任务:\n遍历文件列表 每次遍历就创建一个子进程来执行拷贝任务 线程 进程是分配资源的最小单位. 线程是程序执行的最小单位, 进程分配资源, 线程通过资源来执行程序. 线程自己不拥有系统资源, 同一进程的不同线程可以共享该进程所拥有的资源.\n进程运行时默认会有一个主线程用来执行程序.\nPython 中多线程是一种并发执行任务的方式, 并不是真的并行. 由于全局解释器锁 GIL 的存在，Python 多线程在同一时间只能有一个线程执行.\n线程的创建步骤 导入线程模块\nimport threading 通过线程类创建对象\n\"\"\" arg. target 执行的目标函数名 arg. name 线程名. 默认会按照 thread-1, thread-2...依次递增 arg. group 线程组. 默认为 None \"\"\" t = threading.Thread(target=[目标函数名]) 启动线程对象\nt.start() args 参数的使用 线程传入 args 与进程十分类似:\nt1 = threading.Thread(target=[目标函数名], args=(3,)) t2 = threading.Thread(target=[目标函数名], kwargs={\"arg\": 3}) t1.start() t2.start() 主线程和子线程的结束顺序 import threading import time def work(): for i in range(10): time.sleep(0.2) print(\"sub thread end\") if __name__ == \"__main__\": t1 = threading.Thread(target=work) t1.start() time.sleep(1) print(\"main thread end\") 运行以上代码可以发现结果与进程相似, 主线程会等待子线程运行结束后再结束.\n设置守护进程 和进程的守护进程类似, 线程也可以设置主线程来实现主线程结束后, 所有子线程也都结束.\nt1 = threading.Thread(target=work, daemon=True) ~~# or t1.setDaemon(True)~~ 已废弃 # or t1.daemon = True t1.start() 获取当前线程信息 curr_thread = threading.current_thread() print(curr_thread) 多线程的执行顺序 如果我们创建多个线程执行并打印信息, 可以发现线程的顺序与代码的逻辑顺序不相符.\ndef get_curr_thread(): # funcs... time.sleep(1) curr_thread = threading.current_thread() print(curr_thread) if __name__ == \"__main__\": for i in range(5): t = threading.Thread(target=get_curr_thread) t.start() 你会看到类似以下的输出:\n","wordCount":"371","inLanguage":"en","datePublished":"2025-06-26T14:36:07+08:00","dateModified":"2025-06-26T14:36:07+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://iuwu98005.github.io/posts/250626-python-thread/"},"publisher":{"@type":"Organization","name":"My Blog","logo":{"@type":"ImageObject","url":"https://iuwu98005.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://iuwu98005.github.io/ accesskey=h title="My Blog (Alt + H)">My Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://iuwu98005.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://iuwu98005.github.io/projects/ title=Projects><span>Projects</span></a></li><li><a href=https://iuwu98005.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://iuwu98005.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://iuwu98005.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Python 多线程编程</h1><div class=post-meta><span title='2025-06-26 14:36:07 +0800 +0800'>June 26, 2025</span>&nbsp;·&nbsp;2 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5 aria-label=基本概念>基本概念</a></li><li><a href=#%e8%bf%9b%e7%a8%8b aria-label=进程>进程</a><ul><li><a href=#%e8%bf%9b%e7%a8%8b%e7%9a%84%e6%a6%82%e5%bf%b5 aria-label=进程的概念>进程的概念</a></li><li><a href=#%e5%a4%9a%e8%bf%9b%e7%a8%8b aria-label=多进程>多进程</a></li><li><a href=#%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%88%9b%e5%bb%ba%e6%ad%a5%e9%aa%a4 aria-label=进程的创建步骤>进程的创建步骤</a></li><li><a href=#%e8%bf%9b%e7%a8%8b%e6%89%a7%e8%a1%8c%e5%b8%a6%e6%9c%89%e5%8f%82%e6%95%b0%e7%9a%84%e4%bb%bb%e5%8a%a1 aria-label=进程执行带有参数的任务>进程执行带有参数的任务</a></li><li><a href=#%e8%8e%b7%e5%8f%96%e8%bf%9b%e7%a8%8b%e7%bc%96%e5%8f%b7 aria-label=获取进程编号>获取进程编号</a></li><li><a href=#%e8%bf%9b%e7%a8%8b%e7%9a%84%e6%b3%a8%e6%84%8f%e7%82%b9 aria-label=进程的注意点>进程的注意点</a></li><li><a href=#%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e4%b8%bb%e8%bf%9b%e7%a8%8b%e7%bb%93%e6%9d%9f-%e6%89%80%e6%9c%89%e5%ad%90%e8%bf%9b%e7%a8%8b%e4%b9%9f%e7%bb%93%e6%9d%9f aria-label="如何实现主进程结束, 所有子进程也结束">如何实现主进程结束, 所有子进程也结束</a></li><li><a href=#%e7%bb%93%e5%90%88%e5%ae%9e%e9%99%85%e6%a1%88%e4%be%8b aria-label=结合实际案例>结合实际案例</a></li></ul></li><li><a href=#%e7%ba%bf%e7%a8%8b aria-label=线程>线程</a><ul><li><a href=#%e7%ba%bf%e7%a8%8b%e7%9a%84%e5%88%9b%e5%bb%ba%e6%ad%a5%e9%aa%a4 aria-label=线程的创建步骤>线程的创建步骤</a></li><li><a href=#args-%e5%8f%82%e6%95%b0%e7%9a%84%e4%bd%bf%e7%94%a8 aria-label="args 参数的使用">args 参数的使用</a></li><li><a href=#%e4%b8%bb%e7%ba%bf%e7%a8%8b%e5%92%8c%e5%ad%90%e7%ba%bf%e7%a8%8b%e7%9a%84%e7%bb%93%e6%9d%9f%e9%a1%ba%e5%ba%8f aria-label=主线程和子线程的结束顺序>主线程和子线程的结束顺序</a></li><li><a href=#%e8%ae%be%e7%bd%ae%e5%ae%88%e6%8a%a4%e8%bf%9b%e7%a8%8b aria-label=设置守护进程>设置守护进程</a></li><li><a href=#%e8%8e%b7%e5%8f%96%e5%bd%93%e5%89%8d%e7%ba%bf%e7%a8%8b%e4%bf%a1%e6%81%af aria-label=获取当前线程信息>获取当前线程信息</a></li><li><a href=#%e5%a4%9a%e7%ba%bf%e7%a8%8b%e7%9a%84%e6%89%a7%e8%a1%8c%e9%a1%ba%e5%ba%8f aria-label=多线程的执行顺序>多线程的执行顺序</a></li></ul></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a><ul><li><a href=#%e5%a4%9a%e7%ba%bf%e7%a8%8b%e5%92%8c%e5%a4%9a%e8%bf%9b%e7%a8%8b%e5%af%b9%e6%af%94 aria-label=多线程和多进程对比>多线程和多进程对比</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=基本概念>基本概念<a hidden class=anchor aria-hidden=true href=#基本概念>#</a></h2><p>多任务中的并发和并行</p><ul><li>并发: 一段时间内交替执行任务</li><li>并行: 一段时间内同时执行多个任务</li></ul><h2 id=进程>进程<a hidden class=anchor aria-hidden=true href=#进程>#</a></h2><p>python 中可以通过多进程来实现多任务.</p><h3 id=进程的概念>进程的概念<a hidden class=anchor aria-hidden=true href=#进程的概念>#</a></h3><p>进程 (Process) 是操作系统资源分配和调度的基本单位.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># main.py</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>foo1</span>():<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>foo2</span>():<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>foo1()
</span></span><span style=display:flex><span>foo2()
</span></span></code></pre></div><p>在运行 <code>.py</code> 文件时, 操作系统会创建一个进程, 依次运行 <code>foo1</code> 和 <code>foo2</code> 两个方法.</p><h3 id=多进程>多进程<a hidden class=anchor aria-hidden=true href=#多进程>#</a></h3><p><code>main.py</code> 运行后会创建一个进程, 此时如果再次创建一个进程, 即为子进程. 我们让主进程运行 <code>foo1</code>, 让子进程来运行 <code>foo2</code>即可提升代码运行的效率.</p><h3 id=进程的创建步骤>进程的创建步骤<a hidden class=anchor aria-hidden=true href=#进程的创建步骤>#</a></h3><p>1.导入进程包</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> multiprocessing
</span></span></code></pre></div><p>2.创建进程对象</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>mp <span style=color:#f92672>=</span> multiprocessing<span style=color:#f92672>.</span>Process()
</span></span></code></pre></div><p><code>Process()</code> 方法主要有3个参数:</p><ul><li>target: 执行的目标函数名(方法名), 如 <code>foo2</code></li><li>name: 进程名, 一般不用设置</li><li>group: 进程组, 当前为 <code>None</code></li></ul><p>3.启动进程</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>mp<span style=color:#f92672>.</span>start()
</span></span></code></pre></div><h3 id=进程执行带有参数的任务>进程执行带有参数的任务<a hidden class=anchor aria-hidden=true href=#进程执行带有参数的任务>#</a></h3><ul><li><code>args</code> 以元组方式传参</li><li><code>kwargs</code> 以字典方式传参</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>foo1</span>(argument:int):<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>foo2</span>(argument:int):<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>foo1_process <span style=color:#f92672>=</span> multiprocessing<span style=color:#f92672>.</span>Process(target<span style=color:#f92672>=</span>foo1, args<span style=color:#f92672>=</span>(<span style=color:#ae81ff>3</span>,))
</span></span><span style=display:flex><span>foo1_process<span style=color:#f92672>.</span>start()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>foo2_process <span style=color:#f92672>=</span> multiprocessing<span style=color:#f92672>.</span>Process(target<span style=color:#f92672>=</span>foo2, kwargs<span style=color:#f92672>=</span>{<span style=color:#e6db74>&#34;argument&#34;</span>, <span style=color:#ae81ff>3</span>})
</span></span><span style=display:flex><span>foo2_process<span style=color:#f92672>.</span>start()
</span></span></code></pre></div><h3 id=获取进程编号>获取进程编号<a hidden class=anchor aria-hidden=true href=#获取进程编号>#</a></h3><p>当程序进程数量越来越多时, 为了更好地对进程进行管理, 就需要知道每个进程的编号</p><ol><li><p>获取当前进程编号</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> os
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>os<span style=color:#f92672>.</span>getpid()
</span></span></code></pre></div></li><li><p>获取当前父进程编号</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> os
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>os<span style=color:#f92672>.</span>getppid()
</span></span></code></pre></div></li></ol><p>在方法运行后获取 <code>pid</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>foo1</span>(argument:int):
</span></span><span style=display:flex><span>    <span style=color:#75715e># func</span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;foo1 pid: </span><span style=color:#e6db74>{</span>os<span style=color:#f92672>.</span>getpid()<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>foo2</span>(argument:int):
</span></span><span style=display:flex><span>    <span style=color:#75715e># func</span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;foo2 pid: </span><span style=color:#e6db74>{</span>os<span style=color:#f92672>.</span>getpid()<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;__main__&#34;</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e># 1. 创建子进程对象并指定任务名</span>
</span></span><span style=display:flex><span>    foo1_process <span style=color:#f92672>=</span> multiprocessing<span style=color:#f92672>.</span>Process(target<span style=color:#f92672>=</span>foo1, args<span style=color:#f92672>=</span>(<span style=color:#ae81ff>3</span>,))
</span></span><span style=display:flex><span>    foo2_process <span style=color:#f92672>=</span> multiprocessing<span style=color:#f92672>.</span>Process(target<span style=color:#f92672>=</span>foo2, kwargs<span style=color:#f92672>=</span>{<span style=color:#e6db74>&#34;argument&#34;</span>, <span style=color:#ae81ff>3</span>})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 2. 启动子进程并执行任务</span>
</span></span><span style=display:flex><span>    foo1_process<span style=color:#f92672>.</span>start()
</span></span><span style=display:flex><span>    foo2_process<span style=color:#f92672>.</span>start()
</span></span></code></pre></div><h3 id=进程的注意点>进程的注意点<a hidden class=anchor aria-hidden=true href=#进程的注意点>#</a></h3><p>主进程会等待所有子进程执行完成结束再结束.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>foo1</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>10</span>):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;子进程运行中...&#34;</span>)
</span></span><span style=display:flex><span>        time<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>0.2</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;子进程执行完毕&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;__main__&#34;</span>:
</span></span><span style=display:flex><span>    ps <span style=color:#f92672>=</span> multiprocessing<span style=color:#f92672>.</span>Process(target<span style=color:#f92672>=</span>foo1)
</span></span><span style=display:flex><span>    ps<span style=color:#f92672>.</span>start()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    time<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>0.5</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;主进程执行完毕&#34;</span>)
</span></span></code></pre></div><h3 id=如何实现主进程结束-所有子进程也结束>如何实现主进程结束, 所有子进程也结束<a hidden class=anchor aria-hidden=true href=#如何实现主进程结束-所有子进程也结束>#</a></h3><p>设置守护主进程: <code>ps.daemon = True</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>foo1</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>10</span>):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;子进程运行中...&#34;</span>)
</span></span><span style=display:flex><span>        time<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>0.2</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;子进程执行完毕&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;__main__&#34;</span>:
</span></span><span style=display:flex><span>    ps <span style=color:#f92672>=</span> multiprocessing<span style=color:#f92672>.</span>Process(target<span style=color:#f92672>=</span>foo1)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 设置守护主进程, 主进程推出后子进程自动销毁, 不再执行子进程中的代码</span>
</span></span><span style=display:flex><span>    ps<span style=color:#f92672>.</span>daemon <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>    ps<span style=color:#f92672>.</span>start()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    time<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>0.5</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;主进程执行完毕&#34;</span>)
</span></span></code></pre></div><h3 id=结合实际案例>结合实际案例<a hidden class=anchor aria-hidden=true href=#结合实际案例>#</a></h3><p>如何实现多进程实现拷贝任务:</p><ol><li>遍历文件列表</li><li>每次遍历就创建一个子进程来执行拷贝任务</li></ol><h2 id=线程>线程<a hidden class=anchor aria-hidden=true href=#线程>#</a></h2><p>进程是分配资源的最小单位. 线程是程序执行的最小单位, 进程分配资源, 线程通过资源来执行程序. 线程自己不拥有系统资源, 同一进程的不同线程可以共享该进程所拥有的资源.</p><p>进程运行时默认会有一个主线程用来执行程序.</p><blockquote><p>Python 中多线程是一种<strong>并发</strong>执行任务的方式, 并不是真的并行.
由于全局解释器锁 <code>GIL</code> 的存在，Python 多线程在同一时间只能有一个线程执行.</p></blockquote><h3 id=线程的创建步骤>线程的创建步骤<a hidden class=anchor aria-hidden=true href=#线程的创建步骤>#</a></h3><ol><li><p>导入线程模块</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> threading
</span></span></code></pre></div></li><li><p>通过线程类创建对象</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>arg. target 执行的目标函数名
</span></span></span><span style=display:flex><span><span style=color:#e6db74>arg. name 线程名. 默认会按照 thread-1, thread-2...依次递增
</span></span></span><span style=display:flex><span><span style=color:#e6db74>arg. group 线程组. 默认为 None
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>t <span style=color:#f92672>=</span> threading<span style=color:#f92672>.</span>Thread(target<span style=color:#f92672>=</span>[目标函数名])   
</span></span></code></pre></div></li><li><p>启动线程对象</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>t<span style=color:#f92672>.</span>start()
</span></span></code></pre></div></li></ol><h3 id=args-参数的使用>args 参数的使用<a hidden class=anchor aria-hidden=true href=#args-参数的使用>#</a></h3><p>线程传入 args 与进程十分类似:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>t1 <span style=color:#f92672>=</span> threading<span style=color:#f92672>.</span>Thread(target<span style=color:#f92672>=</span>[目标函数名], args<span style=color:#f92672>=</span>(<span style=color:#ae81ff>3</span>,))
</span></span><span style=display:flex><span>t2 <span style=color:#f92672>=</span> threading<span style=color:#f92672>.</span>Thread(target<span style=color:#f92672>=</span>[目标函数名], kwargs<span style=color:#f92672>=</span>{<span style=color:#e6db74>&#34;arg&#34;</span>: <span style=color:#ae81ff>3</span>})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>t1<span style=color:#f92672>.</span>start()
</span></span><span style=display:flex><span>t2<span style=color:#f92672>.</span>start()
</span></span></code></pre></div><h3 id=主线程和子线程的结束顺序>主线程和子线程的结束顺序<a hidden class=anchor aria-hidden=true href=#主线程和子线程的结束顺序>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> threading
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> time
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>work</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>10</span>):
</span></span><span style=display:flex><span>        time<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>0.2</span>)
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;sub thread end&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;__main__&#34;</span>:
</span></span><span style=display:flex><span>    t1 <span style=color:#f92672>=</span> threading<span style=color:#f92672>.</span>Thread(target<span style=color:#f92672>=</span>work)
</span></span><span style=display:flex><span>    t1<span style=color:#f92672>.</span>start()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    time<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;main thread end&#34;</span>)
</span></span></code></pre></div><p>运行以上代码可以发现结果与进程相似, 主线程会等待子线程运行结束后再结束.</p><h3 id=设置守护进程>设置守护进程<a hidden class=anchor aria-hidden=true href=#设置守护进程>#</a></h3><p>和进程的守护进程类似, 线程也可以设置主线程来实现主线程结束后, 所有子线程也都结束.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>t1 <span style=color:#f92672>=</span> threading<span style=color:#f92672>.</span>Thread(target<span style=color:#f92672>=</span>work, daemon<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>~~</span><span style=color:#75715e># or t1.setDaemon(True)~~ 已废弃</span>
</span></span><span style=display:flex><span><span style=color:#75715e># or t1.daemon = True</span>
</span></span><span style=display:flex><span>t1<span style=color:#f92672>.</span>start()
</span></span></code></pre></div><h3 id=获取当前线程信息>获取当前线程信息<a hidden class=anchor aria-hidden=true href=#获取当前线程信息>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>curr_thread <span style=color:#f92672>=</span> threading<span style=color:#f92672>.</span>current_thread()
</span></span><span style=display:flex><span>print(curr_thread)
</span></span></code></pre></div><h3 id=多线程的执行顺序>多线程的执行顺序<a hidden class=anchor aria-hidden=true href=#多线程的执行顺序>#</a></h3><p>如果我们创建多个线程执行并打印信息, 可以发现线程的顺序与代码的逻辑顺序不相符.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_curr_thread</span>():
</span></span><span style=display:flex><span>    <span style=color:#75715e># funcs...</span>
</span></span><span style=display:flex><span>    time<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    curr_thread <span style=color:#f92672>=</span> threading<span style=color:#f92672>.</span>current_thread()
</span></span><span style=display:flex><span>    print(curr_thread)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;__main__&#34;</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>5</span>):
</span></span><span style=display:flex><span>        t <span style=color:#f92672>=</span> threading<span style=color:#f92672>.</span>Thread(target<span style=color:#f92672>=</span>get_curr_thread)
</span></span><span style=display:flex><span>        t<span style=color:#f92672>.</span>start()
</span></span></code></pre></div><p>你会看到类似以下的输出:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&lt;Thread<span style=color:#f92672>(</span>Thread-1, started 139676544125744<span style=color:#f92672>)</span>&gt;
</span></span><span style=display:flex><span>&lt;Thread<span style=color:#f92672>(</span>Thread-4, started 139676544122342<span style=color:#f92672>)</span>&gt;
</span></span><span style=display:flex><span>&lt;Thread<span style=color:#f92672>(</span>Thread-3, started 139676544124435<span style=color:#f92672>)</span>&gt;
</span></span><span style=display:flex><span>&lt;Thread<span style=color:#f92672>(</span>Thread-2, started 139676544122213<span style=color:#f92672>)</span>&gt;
</span></span><span style=display:flex><span>&lt;Thread<span style=color:#f92672>(</span>Thread-2, started 139676544124535<span style=color:#f92672>)</span>&gt;
</span></span></code></pre></div><p>可以发现程序并不是按照顺序来执行线程的.</p><hr><p>注意有一个例外, 如果我们去掉代码中的 <code>time.sleep(1)</code>后, 可能就会看到终端打印就是按照1.2.3.4.5的顺序来输出.</p><p>由于函数体非常短、几乎不耗时，所以线程执行得极快.</p><p>在这种情况下，由于线程创建和运行都在主线程中顺序执行，很可能第一个线程还没执行完，第二个就开始执行了，而它们执行体积小、竞争少，导致操作系统顺序调度它们（并不是强制顺序，只是调度碰巧是顺序的）.</p><hr><p>我们可以通过 <code>join()</code> 或者 <code>threading.lock()</code> 来控制并发访问的顺序.</p><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>进程是分配资源的最小单位. 线程是程序执行的最小单位, 进程分配资源, 线程通过资源来执行程序. 线程自己不拥有系统资源, 同一进程的不同线程可以共享该进程所拥有的资源.</p><p>进程运行时默认会有一个主线程用来执行程序.</p><h3 id=多线程和多进程对比>多线程和多进程对比<a hidden class=anchor aria-hidden=true href=#多线程和多进程对比>#</a></h3><ol><li>创建进程的资源开销比线程大. 创建主进程的时候所有文件都会加载一遍.</li><li>进程是资源分配的基本单位, 线程是 CPU 调度的基本单位.</li><li>进程可以充分发挥多核的优点. 线程虽然资源开销小, 但是其为并发执行, 并不是真正的并行(由于全局解释器锁 <code>GIL</code> 的存在，Python 多线程在同一时间只能有一个线程执行.)</li></ol></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://iuwu98005.github.io/posts/01_cherrystudio_mcp/><span class=title>Next »</span><br><span>在 Cherry Studio 配置本地 MCP 服务</span></a></nav></footer></article></main><footer class=footer><span>© 2025 IUWU98005</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>