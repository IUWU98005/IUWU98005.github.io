<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>@classmethod 简介与实践应用（251104更新） | My Blog</title><meta name=keywords content><meta name=description content='简单介绍
@classmethod 是与类绑定, 而不是实例的方法. 它的第一个参数是 cls &ndash; 代表当前类对象.

实例方法: 需要创建对象才能使用
类方法: 可以直接通过类调用

class Example:
	@classmethod
	def print_class(cls):
		print(f"this method belongs to class {cls.__name__}")
Example.print_class()
# 输出: this method belongs to class Example
cls 为类方法中的第一个参数, 意味着类方法可以访问和修改类级别的数据, 而不是实例级别的数据.
class Counter:
	count = 1
	def __init__(self):
		Counter.count += 1

	@classmethod
	def print_count(cls):
		print(cls.count)
a = Counter()
b = Counter()
Counter.print_count()
# 输出: 2

实例方法可以通过 self.<attr> 来访问类属性, 类方法可以通过 cls.<attr> 来访问.
在外部可以通过 <Class>.<attr> 来访问类属性.
类方法可以直接调用 cls.<attr> 来对类属性进行修改, 实例方法则需要通过 self.__class__.<attr> 来进行修改.

classmethod 存在的意义
既然实例方法已经可以访问和修改类属性, 为什么还需要实例方法 @classmethod'><meta name=author content><link rel=canonical href=https://iuwu98005.github.io/posts/251028-classmethod/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://iuwu98005.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://iuwu98005.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://iuwu98005.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://iuwu98005.github.io/apple-touch-icon.png><link rel=mask-icon href=https://iuwu98005.github.io/safari-pinned-tab.svg><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#ffffff"><link rel=alternate hreflang=en href=https://iuwu98005.github.io/posts/251028-classmethod/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://iuwu98005.github.io/posts/251028-classmethod/"><meta property="og:site_name" content="My Blog"><meta property="og:title" content="@classmethod 简介与实践应用（251104更新）"><meta property="og:description" content='简单介绍 @classmethod 是与类绑定, 而不是实例的方法. 它的第一个参数是 cls – 代表当前类对象.
实例方法: 需要创建对象才能使用 类方法: 可以直接通过类调用 class Example: @classmethod def print_class(cls): print(f"this method belongs to class {cls.__name__}") Example.print_class() # 输出: this method belongs to class Example cls 为类方法中的第一个参数, 意味着类方法可以访问和修改类级别的数据, 而不是实例级别的数据.
class Counter: count = 1 def __init__(self): Counter.count += 1 @classmethod def print_count(cls): print(cls.count) a = Counter() b = Counter() Counter.print_count() # 输出: 2 实例方法可以通过 self.<attr> 来访问类属性, 类方法可以通过 cls.<attr> 来访问. 在外部可以通过 <Class>.<attr> 来访问类属性. 类方法可以直接调用 cls.<attr> 来对类属性进行修改, 实例方法则需要通过 self.__class__.<attr> 来进行修改. classmethod 存在的意义 既然实例方法已经可以访问和修改类属性, 为什么还需要实例方法 @classmethod'><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-10-28T14:34:35+08:00"><meta property="article:modified_time" content="2025-10-28T14:34:35+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="@classmethod 简介与实践应用（251104更新）"><meta name=twitter:description content='简单介绍
@classmethod 是与类绑定, 而不是实例的方法. 它的第一个参数是 cls &ndash; 代表当前类对象.

实例方法: 需要创建对象才能使用
类方法: 可以直接通过类调用

class Example:
	@classmethod
	def print_class(cls):
		print(f"this method belongs to class {cls.__name__}")
Example.print_class()
# 输出: this method belongs to class Example
cls 为类方法中的第一个参数, 意味着类方法可以访问和修改类级别的数据, 而不是实例级别的数据.
class Counter:
	count = 1
	def __init__(self):
		Counter.count += 1

	@classmethod
	def print_count(cls):
		print(cls.count)
a = Counter()
b = Counter()
Counter.print_count()
# 输出: 2

实例方法可以通过 self.<attr> 来访问类属性, 类方法可以通过 cls.<attr> 来访问.
在外部可以通过 <Class>.<attr> 来访问类属性.
类方法可以直接调用 cls.<attr> 来对类属性进行修改, 实例方法则需要通过 self.__class__.<attr> 来进行修改.

classmethod 存在的意义
既然实例方法已经可以访问和修改类属性, 为什么还需要实例方法 @classmethod'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://iuwu98005.github.io/posts/"},{"@type":"ListItem","position":2,"name":"@classmethod 简介与实践应用（251104更新）","item":"https://iuwu98005.github.io/posts/251028-classmethod/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"@classmethod 简介与实践应用（251104更新）","name":"@classmethod 简介与实践应用（251104更新）","description":"简单介绍 @classmethod 是与类绑定, 而不是实例的方法. 它的第一个参数是 cls \u0026ndash; 代表当前类对象.\n实例方法: 需要创建对象才能使用 类方法: 可以直接通过类调用 class Example: @classmethod def print_class(cls): print(f\u0026#34;this method belongs to class {cls.__name__}\u0026#34;) Example.print_class() # 输出: this method belongs to class Example cls 为类方法中的第一个参数, 意味着类方法可以访问和修改类级别的数据, 而不是实例级别的数据.\nclass Counter: count = 1 def __init__(self): Counter.count += 1 @classmethod def print_count(cls): print(cls.count) a = Counter() b = Counter() Counter.print_count() # 输出: 2 实例方法可以通过 self.\u0026lt;attr\u0026gt; 来访问类属性, 类方法可以通过 cls.\u0026lt;attr\u0026gt; 来访问. 在外部可以通过 \u0026lt;Class\u0026gt;.\u0026lt;attr\u0026gt; 来访问类属性. 类方法可以直接调用 cls.\u0026lt;attr\u0026gt; 来对类属性进行修改, 实例方法则需要通过 self.__class__.\u0026lt;attr\u0026gt; 来进行修改. classmethod 存在的意义 既然实例方法已经可以访问和修改类属性, 为什么还需要实例方法 @classmethod\n","keywords":[],"articleBody":"简单介绍 @classmethod 是与类绑定, 而不是实例的方法. 它的第一个参数是 cls – 代表当前类对象.\n实例方法: 需要创建对象才能使用 类方法: 可以直接通过类调用 class Example: @classmethod def print_class(cls): print(f\"this method belongs to class {cls.__name__}\") Example.print_class() # 输出: this method belongs to class Example cls 为类方法中的第一个参数, 意味着类方法可以访问和修改类级别的数据, 而不是实例级别的数据.\nclass Counter: count = 1 def __init__(self): Counter.count += 1 @classmethod def print_count(cls): print(cls.count) a = Counter() b = Counter() Counter.print_count() # 输出: 2 实例方法可以通过 self. 来访问类属性, 类方法可以通过 cls. 来访问. 在外部可以通过 . 来访问类属性. 类方法可以直接调用 cls. 来对类属性进行修改, 实例方法则需要通过 self.__class__. 来进行修改. classmethod 存在的意义 既然实例方法已经可以访问和修改类属性, 为什么还需要实例方法 @classmethod\n从语义角度来看 实例方法 - 操作对象 类方法(classmethod) - 操作类 静态方法(staticmethod) - 与类相关, 但不操作类或实例 class User: total_user = 0 def __init__(self, name): self.name = name User.total_user += 1 # 根据需求的不同, 这三者承担的职责不同. # 类方法更多是对一个整体的操作 # 当逻辑和整个类有关时, 用`cls`声明这是全局行为 @classmethod def print_total(cls): print(f\"total users: {cls.total_user}\") # 实例方法则是对一个整体内的单个对象进行操作 def rename(self, new_name): if verfiy_name_valid: self.name = new_name else: raise # 静态方法则是与这个整体联系密切的\"工具\" @staticmethod def verify_name_valid() -\u003e bool: ... 从设计角度来看, @classmethod 主要应用于以下场景 工厂方法(Factory method) 全局行为 继承安全 # schemas.py @dataclass class TestDataConfig: waiting: int = 0 prechecking: int = 0 @classmethod def from_dict(cls, data: dict) -\u003e TestDataConfig: return cls( waiting=data.get(\"waiting\", 0), prechecking=data.get(\"prechecking\", 0) ) # api.py resp = requests.post(\"\") return TestDataConfig.from_dict(resp.json()) 上述代码中，使用 @classmethod 创建对象， 有以下几点优点：\n关注点分离， 接口调用者无需关心 Json 如何转换成 TestDataConfig 对象 提高代码可维护性， 将来返回值字段变更， 只需修改 schemas.py 中的字段 代码可复用性，任何符合格式的字典都可以调用 from_dict 来创建对象 代码更整洁，api.py 中不再包含冗长的赋值语句，语义性更强 ORM/数据类封装 @classmethod def from_db_row(cls, row): return cls(**row) # 框架不知道你的类名, 但 `cls` 可以生成正确的实例 classmethod 的继承安全 @classmethod 使用 cls 能自动绑定到调用该方法的类, 因此字类调用该方法时, 返回字类的实例和属性.\n以下面这段代码为例\nclass Factory: def __init__(self):... @classmethod def make(cls): print(f\"Create instance of {cls.__name__}\") return cls() class BikeFactory(Factory):... class CarFactory(Factory):... bike = BikeFactory.make() car = CarFactory.make() # 输出结果为: # Create instance of BikeFactory # Create instance of CarFactory 如果 make() 使用 Factory() 作为返回值, 而不是 cls(), 无论是 CarFactory 还是 BikeFactory 调用它, 最后都会返回 Factory 对象\n20251104 更新 在接口测试中，使用 @dataclass + @classmethod 的组合是实现数据模型层的绝佳方式。它能将接口返回的非结构化 JSON 数据转换为带类型提示、有明确属性的 Python 对象，进而提升代码的质量。\n以下面这段代码为例：\nfrom ..schemas import PostResponse #... class FactoryAPI(BaseAPI): #... def accepet_order(self, order_no: str) -\u003e PostResponse: payload = { \"orderNo\": order_no, } resp = self.client.post(\"/factory/order/accept\", json=payload) return PostResponse.from_dict(resp.json()) 这种模式带来了以下核心优势：\n强类型与静态检查 方法签名 -\u003ePostResponse 提供了明确的返回类型。使得静态类型检查工具（如 autopep8）和 IDE（如 vscode、pycharm）能够进行有效的代码分析、自动补全和错误提示。开发者可以清晰地知道调用此方法后会得到一个拥有哪些属性的对象，而不是一个模糊的 dict 提升代码可读性和可维护性 提供更优雅的访问方式：在业务代码和测试用例中，可以使用 resp.data 来访问数据，而不是 resp[\"data\"]。前者更符合面向对象的直觉，且能避免因手误写错字典键名而导致的 KeyError 关注点分离：FactoryAPI 类专注于“如何与 API 交互”，而PostResponse 类则专注于 “API 返回的数据格式”。如果未来接口返回的字段有变更，我们就只需要改动 PostResponse 中的字段即可，职责清晰，易于维护。 简化 Pytest 测试用例的编写 使用 PostResponse 可以轻松地对返回对象的类型和值进行断言。 编写 @classmethod from_dict 可以承担从原始 dict 到结构化的 PostResponse 对象的转化任务，是连接 API 层和数据模型层的桥梁\n总结\n@dataclass + @classmethod 模式是现代 Python 项目中处理 API 数据的最佳实践之一。它通过引入一个轻量级的数据模型层，极大地增强了代码的可靠性、可读性和可测试性，值得在项目中广泛推广和使用。\n","wordCount":"358","inLanguage":"en","datePublished":"2025-10-28T14:34:35+08:00","dateModified":"2025-10-28T14:34:35+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://iuwu98005.github.io/posts/251028-classmethod/"},"publisher":{"@type":"Organization","name":"My Blog","logo":{"@type":"ImageObject","url":"https://iuwu98005.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://iuwu98005.github.io/ accesskey=h title="My Blog (Alt + H)">My Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://iuwu98005.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://iuwu98005.github.io/projects/ title=Projects><span>Projects</span></a></li><li><a href=https://iuwu98005.github.io/about/ title=About><span>About</span></a></li><li><a href=https://iuwu98005.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://iuwu98005.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://iuwu98005.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">@classmethod 简介与实践应用（251104更新）</h1><div class=post-meta><span title='2025-10-28 14:34:35 +0800 +0800'>October 28, 2025</span>&nbsp;·&nbsp;2 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e7%ae%80%e5%8d%95%e4%bb%8b%e7%bb%8d aria-label=简单介绍>简单介绍</a></li><li><a href=#classmethod-%e5%ad%98%e5%9c%a8%e7%9a%84%e6%84%8f%e4%b9%89 aria-label="classmethod 存在的意义">classmethod 存在的意义</a></li><li><a href=#classmethod-%e7%9a%84%e7%bb%a7%e6%89%bf%e5%ae%89%e5%85%a8 aria-label="classmethod 的继承安全">classmethod 的继承安全</a><ul><ul><ul><li><a href=#20251104-%e6%9b%b4%e6%96%b0 aria-label="20251104 更新">20251104 更新</a></li></ul></ul></ul></li></ul></div></details></div><div class=post-content><h3 id=简单介绍>简单介绍<a hidden class=anchor aria-hidden=true href=#简单介绍>#</a></h3><p><code>@classmethod</code> 是与类绑定, 而不是实例的方法. 它的第一个参数是 <code>cls</code> &ndash; 代表当前类对象.</p><ul><li>实例方法: 需要创建对象才能使用</li><li>类方法: 可以直接通过类调用</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Example</span>:
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@classmethod</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>print_class</span>(cls):
</span></span><span style=display:flex><span>		print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;this method belongs to class </span><span style=color:#e6db74>{</span>cls<span style=color:#f92672>.</span>__name__<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span>Example<span style=color:#f92672>.</span>print_class()
</span></span><span style=display:flex><span><span style=color:#75715e># 输出: this method belongs to class Example</span>
</span></span></code></pre></div><p><code>cls</code> 为类方法中的第一个参数, 意味着类方法可以访问和修改类级别的数据, 而不是实例级别的数据.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Counter</span>:
</span></span><span style=display:flex><span>	count <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self):
</span></span><span style=display:flex><span>		Counter<span style=color:#f92672>.</span>count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@classmethod</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>print_count</span>(cls):
</span></span><span style=display:flex><span>		print(cls<span style=color:#f92672>.</span>count)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span>a <span style=color:#f92672>=</span> Counter()
</span></span><span style=display:flex><span>b <span style=color:#f92672>=</span> Counter()
</span></span><span style=display:flex><span>Counter<span style=color:#f92672>.</span>print_count()
</span></span><span style=display:flex><span><span style=color:#75715e># 输出: 2</span>
</span></span></code></pre></div><ul><li>实例方法可以通过 <code>self.&lt;attr></code> 来访问类属性, 类方法可以通过 <code>cls.&lt;attr></code> 来访问.</li><li>在外部可以通过 <code>&lt;Class>.&lt;attr></code> 来访问类属性.</li><li>类方法可以直接调用 <code>cls.&lt;attr></code> 来对类属性进行修改, 实例方法则需要通过 <code>self.__class__.&lt;attr></code> 来进行修改.</li></ul><h3 id=classmethod-存在的意义>classmethod 存在的意义<a hidden class=anchor aria-hidden=true href=#classmethod-存在的意义>#</a></h3><p>既然实例方法已经可以访问和修改类属性, 为什么还需要实例方法 <code>@classmethod</code></p><ol><li>从语义角度来看<ul><li>实例方法 - 操作对象</li><li>类方法(classmethod) - 操作类</li><li>静态方法(staticmethod) - 与类相关, 但不操作类或实例</li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>User</span>:
</span></span><span style=display:flex><span>	total_user <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self, name):
</span></span><span style=display:flex><span>		self<span style=color:#f92672>.</span>name <span style=color:#f92672>=</span> name
</span></span><span style=display:flex><span>		User<span style=color:#f92672>.</span>total_user <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e># 根据需求的不同, 这三者承担的职责不同.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e># 类方法更多是对一个整体的操作</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e># 当逻辑和整个类有关时, 用`cls`声明这是全局行为</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@classmethod</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>print_total</span>(cls):
</span></span><span style=display:flex><span>		print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;total users: </span><span style=color:#e6db74>{</span>cls<span style=color:#f92672>.</span>total_user<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e># 实例方法则是对一个整体内的单个对象进行操作</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>rename</span>(self, new_name):
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> verfiy_name_valid:
</span></span><span style=display:flex><span>			self<span style=color:#f92672>.</span>name <span style=color:#f92672>=</span> new_name
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>raise</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e># 静态方法则是与这个整体联系密切的&#34;工具&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@staticmethod</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>verify_name_valid</span>() <span style=color:#f92672>-&gt;</span> bool:
</span></span><span style=display:flex><span>		<span style=color:#f92672>...</span>
</span></span></code></pre></div><ol start=2><li>从设计角度来看, <code>@classmethod</code> 主要应用于以下场景<ul><li>工厂方法(Factory method)</li><li>全局行为</li><li>继承安全</li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=color:#75715e># schemas.py</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@dataclass</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TestDataConfig</span>:
</span></span><span style=display:flex><span>	waiting: int <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	prechecking: int <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@classmethod</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>from_dict</span>(cls, data: dict) <span style=color:#f92672>-&gt;</span> TestDataConfig:
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> cls(
</span></span><span style=display:flex><span>			waiting<span style=color:#f92672>=</span>data<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;waiting&#34;</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>			prechecking<span style=color:#f92672>=</span>data<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;prechecking&#34;</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>		)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=color:#75715e># api.py</span>
</span></span><span style=display:flex><span>resp <span style=color:#f92672>=</span> requests<span style=color:#f92672>.</span>post(<span style=color:#e6db74>&#34;&lt;url&gt;&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> TestDataConfig<span style=color:#f92672>.</span>from_dict(resp<span style=color:#f92672>.</span>json())
</span></span></code></pre></div><p>上述代码中，使用 <code>@classmethod</code> 创建对象， 有以下几点优点：</p><ul><li>关注点分离， 接口调用者无需关心 Json 如何转换成 <code>TestDataConfig</code> 对象</li><li>提高代码可维护性， 将来返回值字段变更， 只需修改 <code>schemas.py</code> 中的字段</li><li>代码可复用性，任何符合格式的字典都可以调用 <code>from_dict</code> 来创建对象</li><li>代码更整洁，<code>api.py</code> 中不再包含冗长的赋值语句，语义性更强</li></ul><ol start=3><li>ORM/数据类封装</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=color:#a6e22e>@classmethod</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>from_db_row</span>(cls, row):
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> cls(<span style=color:#f92672>**</span>row)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 框架不知道你的类名, 但 `cls` 可以生成正确的实例</span>
</span></span></code></pre></div><h3 id=classmethod-的继承安全>classmethod 的继承安全<a hidden class=anchor aria-hidden=true href=#classmethod-的继承安全>#</a></h3><p><code>@classmethod</code> 使用 <code>cls</code> 能自动绑定到<strong>调用该方法的类</strong>, 因此字类调用该方法时, 返回字类的实例和属性.</p><p>以下面这段代码为例</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Factory</span>:
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self):<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@classmethod</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>make</span>(cls):
</span></span><span style=display:flex><span>		print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Create instance of </span><span style=color:#e6db74>{</span>cls<span style=color:#f92672>.</span>__name__<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> cls()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BikeFactory</span>(Factory):<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CarFactory</span>(Factory):<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>bike <span style=color:#f92672>=</span> BikeFactory<span style=color:#f92672>.</span>make()
</span></span><span style=display:flex><span>car <span style=color:#f92672>=</span> CarFactory<span style=color:#f92672>.</span>make()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 输出结果为:</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Create instance of BikeFactory</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Create instance of CarFactory</span>
</span></span></code></pre></div><blockquote><p>如果 <code>make()</code> 使用 <code>Factory()</code> 作为返回值, 而不是 <code>cls()</code>, 无论是 <code>CarFactory</code> 还是 <code>BikeFactory</code> 调用它, 最后都会返回 <code>Factory</code> 对象</p></blockquote><hr><h6 id=20251104-更新>20251104 更新<a hidden class=anchor aria-hidden=true href=#20251104-更新>#</a></h6><p>在接口测试中，使用 <code>@dataclass</code> + <code>@classmethod</code> 的组合是实现数据模型层的绝佳方式。它能将接口返回的非结构化 JSON 数据转换为带类型提示、有明确属性的 Python 对象，进而提升代码的质量。</p><p>以下面这段代码为例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=color:#f92672>from</span> ..schemas <span style=color:#f92672>import</span> PostResponse
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FactoryAPI</span>(BaseAPI):
</span></span><span style=display:flex><span>	<span style=color:#75715e>#...</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>accepet_order</span>(self, order_no: str) <span style=color:#f92672>-&gt;</span> PostResponse:
</span></span><span style=display:flex><span>		payload <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>			<span style=color:#e6db74>&#34;orderNo&#34;</span>: order_no,
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		resp <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>client<span style=color:#f92672>.</span>post(<span style=color:#e6db74>&#34;/factory/order/accept&#34;</span>, json<span style=color:#f92672>=</span>payload)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> PostResponse<span style=color:#f92672>.</span>from_dict(resp<span style=color:#f92672>.</span>json())
</span></span></code></pre></div><p>这种模式带来了以下核心优势：</p><ol><li><strong>强类型与静态检查</strong><ol><li>方法签名 <code>->PostResponse</code> 提供了明确的返回类型。使得静态类型检查工具（如 autopep8）和 IDE（如 vscode、pycharm）能够进行有效的代码分析、自动补全和错误提示。开发者可以清晰地知道调用此方法后会得到一个拥有哪些属性的对象，而不是一个模糊的 <code>dict</code></li></ol></li><li><strong>提升代码可读性和可维护性</strong><ol><li>提供更优雅的访问方式：在业务代码和测试用例中，可以使用 <code>resp.data</code> 来访问数据，而不是 <code>resp["data"]</code>。前者更符合面向对象的直觉，且能避免因手误写错字典键名而导致的 <code>KeyError</code></li><li>关注点分离：<code>FactoryAPI</code> 类专注于“如何与 API 交互”，而<code>PostResponse</code> 类则专注于 “API 返回的数据格式”。如果未来接口返回的字段有变更，我们就只需要改动 <code>PostResponse</code> 中的字段即可，职责清晰，易于维护。</li></ol></li><li><strong>简化 Pytest 测试用例的编写</strong><ol><li>使用 <code>PostResponse</code> 可以轻松地对返回对象的<strong>类型</strong>和<strong>值</strong>进行断言。</li></ol></li></ol><blockquote><p>编写 <code>@classmethod</code> <code>from_dict</code> 可以承担从原始 <code>dict</code> 到结构化的 <code>PostResponse</code> 对象的转化任务，是连接 API 层和数据模型层的桥梁</p></blockquote><p><strong>总结</strong></p><p><code>@dataclass</code> + <code>@classmethod</code>  模式是现代 Python 项目中处理 API 数据的最佳实践之一。它通过引入一个轻量级的数据模型层，极大地增强了代码的可靠性、可读性和可测试性，值得在项目中广泛推广和使用。</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://iuwu98005.github.io/posts/250916-clash-verge-rev/><span class=title>Next »</span><br><span>记录 Clash Verge Rev 使用过程中遇到的问题及解决方案(25.09.23更新)</span></a></nav></footer></article></main><footer class=footer><span>© 2025 IUWU98005</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>