<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>251028 Classmethod | My Blog</title><meta name=keywords content><meta name=description content='简单介绍
@classmethod 是与类绑定, 而不是实例的方法. 它的第一个参数是 cls &ndash; 代表当前类对象.

实例方法: 需要创建对象才能使用
类方法: 可以直接通过类调用

class Example:
	@classmethod
	def print_class(cls):
		print(f"this method belongs to class {cls.__name__}")
Example.print_class()
# 输出: this method belongs to class Example
cls 为类方法中的第一个参数, 意味着类方法可以访问和修改类级别的数据, 而不是实例级别的数据.
class Counter:
	count = 1
	def __init__(self):
		Counter.count += 1

	@classmethod
	def print_count(cls):
		print(cls.count)
a = Counter()
b = Counter()
Counter.print_count()
# 输出: 2

实例方法可以通过 self.<attr> 来访问类属性, 类方法可以通过 cls.<attr> 来访问.
在外部可以通过 <Class>.<attr> 来访问类属性.
类方法可以直接调用 cls.<attr> 来对类属性进行修改, 实例方法则需要通过 self.__class__.<attr> 来进行修改.

classmethod 存在的意义
既然实例方法已经可以访问和修改类属性, 为什么还需要实例方法 @classmethod'><meta name=author content><link rel=canonical href=https://iuwu98005.github.io/posts/251028-classmethod/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://iuwu98005.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://iuwu98005.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://iuwu98005.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://iuwu98005.github.io/apple-touch-icon.png><link rel=mask-icon href=https://iuwu98005.github.io/safari-pinned-tab.svg><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#ffffff"><link rel=alternate hreflang=en href=https://iuwu98005.github.io/posts/251028-classmethod/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://iuwu98005.github.io/posts/251028-classmethod/"><meta property="og:site_name" content="My Blog"><meta property="og:title" content="251028 Classmethod"><meta property="og:description" content='简单介绍 @classmethod 是与类绑定, 而不是实例的方法. 它的第一个参数是 cls – 代表当前类对象.
实例方法: 需要创建对象才能使用 类方法: 可以直接通过类调用 class Example: @classmethod def print_class(cls): print(f"this method belongs to class {cls.__name__}") Example.print_class() # 输出: this method belongs to class Example cls 为类方法中的第一个参数, 意味着类方法可以访问和修改类级别的数据, 而不是实例级别的数据.
class Counter: count = 1 def __init__(self): Counter.count += 1 @classmethod def print_count(cls): print(cls.count) a = Counter() b = Counter() Counter.print_count() # 输出: 2 实例方法可以通过 self.<attr> 来访问类属性, 类方法可以通过 cls.<attr> 来访问. 在外部可以通过 <Class>.<attr> 来访问类属性. 类方法可以直接调用 cls.<attr> 来对类属性进行修改, 实例方法则需要通过 self.__class__.<attr> 来进行修改. classmethod 存在的意义 既然实例方法已经可以访问和修改类属性, 为什么还需要实例方法 @classmethod'><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-10-28T14:34:35+08:00"><meta property="article:modified_time" content="2025-10-28T14:34:35+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="251028 Classmethod"><meta name=twitter:description content='简单介绍
@classmethod 是与类绑定, 而不是实例的方法. 它的第一个参数是 cls &ndash; 代表当前类对象.

实例方法: 需要创建对象才能使用
类方法: 可以直接通过类调用

class Example:
	@classmethod
	def print_class(cls):
		print(f"this method belongs to class {cls.__name__}")
Example.print_class()
# 输出: this method belongs to class Example
cls 为类方法中的第一个参数, 意味着类方法可以访问和修改类级别的数据, 而不是实例级别的数据.
class Counter:
	count = 1
	def __init__(self):
		Counter.count += 1

	@classmethod
	def print_count(cls):
		print(cls.count)
a = Counter()
b = Counter()
Counter.print_count()
# 输出: 2

实例方法可以通过 self.<attr> 来访问类属性, 类方法可以通过 cls.<attr> 来访问.
在外部可以通过 <Class>.<attr> 来访问类属性.
类方法可以直接调用 cls.<attr> 来对类属性进行修改, 实例方法则需要通过 self.__class__.<attr> 来进行修改.

classmethod 存在的意义
既然实例方法已经可以访问和修改类属性, 为什么还需要实例方法 @classmethod'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://iuwu98005.github.io/posts/"},{"@type":"ListItem","position":2,"name":"251028 Classmethod","item":"https://iuwu98005.github.io/posts/251028-classmethod/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"251028 Classmethod","name":"251028 Classmethod","description":"简单介绍 @classmethod 是与类绑定, 而不是实例的方法. 它的第一个参数是 cls \u0026ndash; 代表当前类对象.\n实例方法: 需要创建对象才能使用 类方法: 可以直接通过类调用 class Example: @classmethod def print_class(cls): print(f\u0026#34;this method belongs to class {cls.__name__}\u0026#34;) Example.print_class() # 输出: this method belongs to class Example cls 为类方法中的第一个参数, 意味着类方法可以访问和修改类级别的数据, 而不是实例级别的数据.\nclass Counter: count = 1 def __init__(self): Counter.count += 1 @classmethod def print_count(cls): print(cls.count) a = Counter() b = Counter() Counter.print_count() # 输出: 2 实例方法可以通过 self.\u0026lt;attr\u0026gt; 来访问类属性, 类方法可以通过 cls.\u0026lt;attr\u0026gt; 来访问. 在外部可以通过 \u0026lt;Class\u0026gt;.\u0026lt;attr\u0026gt; 来访问类属性. 类方法可以直接调用 cls.\u0026lt;attr\u0026gt; 来对类属性进行修改, 实例方法则需要通过 self.__class__.\u0026lt;attr\u0026gt; 来进行修改. classmethod 存在的意义 既然实例方法已经可以访问和修改类属性, 为什么还需要实例方法 @classmethod\n","keywords":[],"articleBody":"简单介绍 @classmethod 是与类绑定, 而不是实例的方法. 它的第一个参数是 cls – 代表当前类对象.\n实例方法: 需要创建对象才能使用 类方法: 可以直接通过类调用 class Example: @classmethod def print_class(cls): print(f\"this method belongs to class {cls.__name__}\") Example.print_class() # 输出: this method belongs to class Example cls 为类方法中的第一个参数, 意味着类方法可以访问和修改类级别的数据, 而不是实例级别的数据.\nclass Counter: count = 1 def __init__(self): Counter.count += 1 @classmethod def print_count(cls): print(cls.count) a = Counter() b = Counter() Counter.print_count() # 输出: 2 实例方法可以通过 self. 来访问类属性, 类方法可以通过 cls. 来访问. 在外部可以通过 . 来访问类属性. 类方法可以直接调用 cls. 来对类属性进行修改, 实例方法则需要通过 self.__class__. 来进行修改. classmethod 存在的意义 既然实例方法已经可以访问和修改类属性, 为什么还需要实例方法 @classmethod\n从语义角度来看 实例方法 - 操作对象 类方法(classmethod) - 操作类 静态方法(staticmethod) - 与类相关, 但不操作类或实例 从设计角度来看, @classmethod 主要应用于以下场景 工厂方法(Factory method) 全局行为 继承安全 class User: total_user = 0 def __init__(self, name): self.name = name User.total_user += 1 # 根据需求的不同, 这三者承担的职责不同. # 类方法更多是对一个整体的操作 # 当逻辑和整个类有关时, 用`cls`声明这是全局行为 @classmethod def print_total(cls): print(f\"total users: {cls.total_user}\") # 实例方法则是对一个整体内的单个对象进行操作 def rename(self, new_name): if verfiy_name_valid: self.name = new_name else: raise # 静态方法则是与这个整体联系密切的\"工具\" @staticmethod def verify_name_valid() -\u003e bool: ... 工厂方法(Factory method) 提供了不同的方式来创建对象, 而不仅限于 __init__.\n@dataclass class TestDataConfig: waiting: int = 0 prechecking: int = 0 @classmethod def from_dict(cls, data: dict) -\u003e TestDataConfig: return cls( waiting=data.get(\"waiting\", 0), prechecking=data.get(\"prechecking\", 0) ) @dataclass 自动提供了 __init__, __repr__, __eq__ 等基础方法. 主要用于数据封装类(如配置项、参数对象)\n# 可以通过以下方法来创建对象并赋值 config_dict = getattr(request, \"param\", {\"waiting\": 1, \"prechecking\": 1}) config = TestDataConfig.from_dict(config_dict) classmethod 的继承安全 @classmethod 使用 cls 能自动绑定到调用该方法的类, 因此字类调用该方法时, 返回字类的实例和属性.\n以下面这段代码为例\nclass Factory: def __init__(self):... @classmethod def make(cls): print(f\"Create instance of {cls.__name__}\") return cls() class BikeFactory(Factory):... class CarFactory(Factory):... bike = BikeFactory.make() car = CarFactory.make() # 输出结果为: # Create instance of BikeFactory # Create instance of CarFactory 如果 make() 使用 Factory() 作为返回值, 而不是 cls(), 无论是 CarFactory 还是 BikeFactory 调用它, 最后都会返回 Factory 对象\n那么这个特性有什么用呢, 以下是常见的用法\n提供更多初始化方法方式\nclass User: def __init__(self, name, age): self.name = name self.age = age @classmethod def from_dict(cls, data): return cls(data[\"name\"], data[\"age\"]) # 让类拥有更灵活的\"构造接口\", 可以直接传字典或其他自定义格式, 同时使语义更加明确 # user = User.from_dict({\"name\": \"Alice\", \"age\": \"18\"}) # 等价于 user = User(name=\"Alice\", age=\"18\") ORM/数据类封装\n@classmethod def from_db_row(cls, row): return cls(**row) # 框架不知道你的类名, 但 `cls` 可以生成正确的实例 ","wordCount":"306","inLanguage":"en","datePublished":"2025-10-28T14:34:35+08:00","dateModified":"2025-10-28T14:34:35+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://iuwu98005.github.io/posts/251028-classmethod/"},"publisher":{"@type":"Organization","name":"My Blog","logo":{"@type":"ImageObject","url":"https://iuwu98005.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://iuwu98005.github.io/ accesskey=h title="My Blog (Alt + H)">My Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://iuwu98005.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://iuwu98005.github.io/projects/ title=Projects><span>Projects</span></a></li><li><a href=https://iuwu98005.github.io/about/ title=About><span>About</span></a></li><li><a href=https://iuwu98005.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://iuwu98005.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://iuwu98005.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">251028 Classmethod</h1><div class=post-meta><span title='2025-10-28 14:34:35 +0800 +0800'>October 28, 2025</span>&nbsp;·&nbsp;2 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e7%ae%80%e5%8d%95%e4%bb%8b%e7%bb%8d aria-label=简单介绍>简单介绍</a></li><li><a href=#classmethod-%e5%ad%98%e5%9c%a8%e7%9a%84%e6%84%8f%e4%b9%89 aria-label="classmethod 存在的意义">classmethod 存在的意义</a></li><li><a href=#classmethod-%e7%9a%84%e7%bb%a7%e6%89%bf%e5%ae%89%e5%85%a8 aria-label="classmethod 的继承安全">classmethod 的继承安全</a></li></ul></div></details></div><div class=post-content><h3 id=简单介绍>简单介绍<a hidden class=anchor aria-hidden=true href=#简单介绍>#</a></h3><p><code>@classmethod</code> 是与类绑定, 而不是实例的方法. 它的第一个参数是 <code>cls</code> &ndash; 代表当前类对象.</p><ul><li>实例方法: 需要创建对象才能使用</li><li>类方法: 可以直接通过类调用</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Example</span>:
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@classmethod</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>print_class</span>(cls):
</span></span><span style=display:flex><span>		print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;this method belongs to class </span><span style=color:#e6db74>{</span>cls<span style=color:#f92672>.</span>__name__<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span>Example<span style=color:#f92672>.</span>print_class()
</span></span><span style=display:flex><span><span style=color:#75715e># 输出: this method belongs to class Example</span>
</span></span></code></pre></div><p><code>cls</code> 为类方法中的第一个参数, 意味着类方法可以访问和修改类级别的数据, 而不是实例级别的数据.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Counter</span>:
</span></span><span style=display:flex><span>	count <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self):
</span></span><span style=display:flex><span>		Counter<span style=color:#f92672>.</span>count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@classmethod</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>print_count</span>(cls):
</span></span><span style=display:flex><span>		print(cls<span style=color:#f92672>.</span>count)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span>a <span style=color:#f92672>=</span> Counter()
</span></span><span style=display:flex><span>b <span style=color:#f92672>=</span> Counter()
</span></span><span style=display:flex><span>Counter<span style=color:#f92672>.</span>print_count()
</span></span><span style=display:flex><span><span style=color:#75715e># 输出: 2</span>
</span></span></code></pre></div><ul><li>实例方法可以通过 <code>self.&lt;attr></code> 来访问类属性, 类方法可以通过 <code>cls.&lt;attr></code> 来访问.</li><li>在外部可以通过 <code>&lt;Class>.&lt;attr></code> 来访问类属性.</li><li>类方法可以直接调用 <code>cls.&lt;attr></code> 来对类属性进行修改, 实例方法则需要通过 <code>self.__class__.&lt;attr></code> 来进行修改.</li></ul><h3 id=classmethod-存在的意义>classmethod 存在的意义<a hidden class=anchor aria-hidden=true href=#classmethod-存在的意义>#</a></h3><p>既然实例方法已经可以访问和修改类属性, 为什么还需要实例方法 <code>@classmethod</code></p><ol><li>从语义角度来看<ul><li>实例方法 - 操作对象</li><li>类方法(classmethod) - 操作类</li><li>静态方法(staticmethod) - 与类相关, 但不操作类或实例</li></ul></li><li>从设计角度来看, <code>@classmethod</code> 主要应用于以下场景<ul><li>工厂方法(Factory method)</li><li>全局行为</li><li>继承安全</li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>User</span>:
</span></span><span style=display:flex><span>	total_user <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self, name):
</span></span><span style=display:flex><span>		self<span style=color:#f92672>.</span>name <span style=color:#f92672>=</span> name
</span></span><span style=display:flex><span>		User<span style=color:#f92672>.</span>total_user <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e># 根据需求的不同, 这三者承担的职责不同.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e># 类方法更多是对一个整体的操作</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e># 当逻辑和整个类有关时, 用`cls`声明这是全局行为</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@classmethod</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>print_total</span>(cls):
</span></span><span style=display:flex><span>		print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;total users: </span><span style=color:#e6db74>{</span>cls<span style=color:#f92672>.</span>total_user<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e># 实例方法则是对一个整体内的单个对象进行操作</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>rename</span>(self, new_name):
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> verfiy_name_valid:
</span></span><span style=display:flex><span>			self<span style=color:#f92672>.</span>name <span style=color:#f92672>=</span> new_name
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>raise</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e># 静态方法则是与这个整体联系密切的&#34;工具&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@staticmethod</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>verify_name_valid</span>() <span style=color:#f92672>-&gt;</span> bool:
</span></span><span style=display:flex><span>		<span style=color:#f92672>...</span>
</span></span></code></pre></div><p>工厂方法(Factory method) 提供了不同的方式来创建对象, 而不仅限于 <code>__init__</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=color:#a6e22e>@dataclass</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TestDataConfig</span>:
</span></span><span style=display:flex><span>	waiting: int <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	prechecking: int <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@classmethod</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>from_dict</span>(cls, data: dict) <span style=color:#f92672>-&gt;</span> TestDataConfig:
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> cls(
</span></span><span style=display:flex><span>			waiting<span style=color:#f92672>=</span>data<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;waiting&#34;</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>			prechecking<span style=color:#f92672>=</span>data<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;prechecking&#34;</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>		)
</span></span></code></pre></div><blockquote><p><code>@dataclass</code> 自动提供了 <code>__init__</code>, <code>__repr__</code>, <code>__eq__</code> 等基础方法. 主要用于<strong>数据封装类</strong>(如配置项、参数对象)</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=color:#75715e># 可以通过以下方法来创建对象并赋值</span>
</span></span><span style=display:flex><span>config_dict <span style=color:#f92672>=</span> getattr(request, <span style=color:#e6db74>&#34;param&#34;</span>, {<span style=color:#e6db74>&#34;waiting&#34;</span>: <span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;prechecking&#34;</span>: <span style=color:#ae81ff>1</span>})
</span></span><span style=display:flex><span>config <span style=color:#f92672>=</span> TestDataConfig<span style=color:#f92672>.</span>from_dict(config_dict)
</span></span></code></pre></div><h3 id=classmethod-的继承安全>classmethod 的继承安全<a hidden class=anchor aria-hidden=true href=#classmethod-的继承安全>#</a></h3><p><code>@classmethod</code> 使用 <code>cls</code> 能自动绑定到<strong>调用该方法的类</strong>, 因此字类调用该方法时, 返回字类的实例和属性.</p><p>以下面这段代码为例</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Factory</span>:
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self):<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@classmethod</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>make</span>(cls):
</span></span><span style=display:flex><span>		print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Create instance of </span><span style=color:#e6db74>{</span>cls<span style=color:#f92672>.</span>__name__<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> cls()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BikeFactory</span>(Factory):<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CarFactory</span>(Factory):<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>bike <span style=color:#f92672>=</span> BikeFactory<span style=color:#f92672>.</span>make()
</span></span><span style=display:flex><span>car <span style=color:#f92672>=</span> CarFactory<span style=color:#f92672>.</span>make()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 输出结果为:</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Create instance of BikeFactory</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Create instance of CarFactory</span>
</span></span></code></pre></div><blockquote><p>如果 <code>make()</code> 使用 <code>Factory()</code> 作为返回值, 而不是 <code>cls()</code>, 无论是 <code>CarFactory</code> 还是 <code>BikeFactory</code> 调用它, 最后都会返回 <code>Factory</code> 对象</p></blockquote><p>那么这个特性有什么用呢, 以下是常见的用法</p><ol><li><p>提供更多初始化方法方式</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>User</span>:
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self, name, age):
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>name <span style=color:#f92672>=</span> name
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>age <span style=color:#f92672>=</span> age
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@classmethod</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>from_dict</span>(cls, data):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> cls(data[<span style=color:#e6db74>&#34;name&#34;</span>], data[<span style=color:#e6db74>&#34;age&#34;</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 让类拥有更灵活的&#34;构造接口&#34;, 可以直接传字典或其他自定义格式, 同时使语义更加明确</span>
</span></span><span style=display:flex><span><span style=color:#75715e># user = User.from_dict({&#34;name&#34;: &#34;Alice&#34;, &#34;age&#34;: &#34;18&#34;})</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 等价于 user = User(name=&#34;Alice&#34;, age=&#34;18&#34;)</span>
</span></span></code></pre></div></li><li><p>ORM/数据类封装</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=color:#a6e22e>@classmethod</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>from_db_row</span>(cls, row):
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> cls(<span style=color:#f92672>**</span>row)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 框架不知道你的类名, 但 `cls` 可以生成正确的实例</span>
</span></span></code></pre></div></li></ol></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://iuwu98005.github.io/posts/250916-clash-verge-rev/><span class=title>Next »</span><br><span>记录 Clash Verge Rev 使用过程中遇到的问题及解决方案(25.09.23更新)</span></a></nav></footer></article></main><footer class=footer><span>© 2025 IUWU98005</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>