<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>使用 ThreadPoolExecutor 和 Barrier 进行接口并发测试 | My Blog</title><meta name=keywords content><meta name=description content='下面以接口支付并发为例，演示如何通过 ThreadPoolExecutor + Barrier 同步触发请求，并收集结果与错误信息。
示例代码
import threading
from concurrent.futures import FIRST_EXCEPTION, ThreadPoolExecutor, wait
from typing import Any, Optional

import pytest

from api import OrderAPI
from factory import order_pay_payload

class TestOrderPay:

    @pytest.mark.concurrent
    @pytest.mark.parametrize(
        "generator", [{"pay_need": 5, "user_id": 10005, "org_id": 1}], indirect=True
    )
    def test_concurrent_req(self, order_api: OrderAPI, generator: dict):
        """并发支付，确保只有一个请求成功，其余请求失败"""
        order_nos: list = [order["orderNo"] for order in generator["pay_need_orders"]]

        n: int = len(order_nos)
        barrier: threading.Barrier = threading.Barrier(n)

        results: list[dict[str, Any]] = []
        errors: dict[str, str] = {}

        def worker(order_no: str) -> Optional[dict[str, Any]]:
            try:
                barrier.wait(timeout=5)

                data = order_api.pay_order(payload=order_pay_payload(order_no=order_no))

                return {
                    "order_no": order_no,
                    "success": data["success"],
                    "code": data["code"],
                    "message": data["message"],
                }

            except threading.BrokenBarrierError as e:
                errors[order_no] = str(e)
                return None
            except Exception as e:
                errors[order_no] = str(e)
                return None

        with ThreadPoolExecutor(max_workers=n) as executor:
            # 记录所有 future 对象以及其对应的 order_no
            future_map = {executor.submit(worker, order_no): order_no for order_no in order_nos}

            done, not_done = wait(
                future_map, return_when=FIRST_EXCEPTION, timeout=10
            )

            for future in done:
                result = future.result()
                if result:
                    results.append(result)

            for future in not_done:
                order_no = future_map[future]
                future.cancel()
                errors[order_no] = "Request timed out or was cancelled."

        assert len(errors) == 0, f"Errors occurred during requests: {errors}"

        assert len([r for r in results if r.get("success") is True]) == 1
说明

Barrier 用于对齐所有线程的起跑线，确保在同一时间点发起请求，模拟高并发场景。
barrier.wait(timeout=5) 会阻塞线程，直到所有线程都到达或超时。
通过 wait(..., return_when=FIRST_EXCEPTION) 可以在发生首个异常后提前结束等待，避免无意义的长时间阻塞。
future_map 用于将 Future 与 order_no 关联，便于定位超时或异常请求。

额外注意
requests 默认的连接池大小为 10。如果并发测试需要更高的连接数，需要手动配置连接池（例如通过 HTTPAdapter(pool_maxsize=...)）以避免连接数成为瓶颈。'><meta name=author content><link rel=canonical href=https://iuwu98005.github.io/posts/26012202/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://iuwu98005.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://iuwu98005.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://iuwu98005.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://iuwu98005.github.io/apple-touch-icon.png><link rel=mask-icon href=https://iuwu98005.github.io/safari-pinned-tab.svg><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#ffffff"><link rel=alternate hreflang=en href=https://iuwu98005.github.io/posts/26012202/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://iuwu98005.github.io/posts/26012202/"><meta property="og:site_name" content="My Blog"><meta property="og:title" content="使用 ThreadPoolExecutor 和 Barrier 进行接口并发测试"><meta property="og:description" content='下面以接口支付并发为例，演示如何通过 ThreadPoolExecutor + Barrier 同步触发请求，并收集结果与错误信息。
示例代码 import threading from concurrent.futures import FIRST_EXCEPTION, ThreadPoolExecutor, wait from typing import Any, Optional import pytest from api import OrderAPI from factory import order_pay_payload class TestOrderPay: @pytest.mark.concurrent @pytest.mark.parametrize( "generator", [{"pay_need": 5, "user_id": 10005, "org_id": 1}], indirect=True ) def test_concurrent_req(self, order_api: OrderAPI, generator: dict): """并发支付，确保只有一个请求成功，其余请求失败""" order_nos: list = [order["orderNo"] for order in generator["pay_need_orders"]] n: int = len(order_nos) barrier: threading.Barrier = threading.Barrier(n) results: list[dict[str, Any]] = [] errors: dict[str, str] = {} def worker(order_no: str) -> Optional[dict[str, Any]]: try: barrier.wait(timeout=5) data = order_api.pay_order(payload=order_pay_payload(order_no=order_no)) return { "order_no": order_no, "success": data["success"], "code": data["code"], "message": data["message"], } except threading.BrokenBarrierError as e: errors[order_no] = str(e) return None except Exception as e: errors[order_no] = str(e) return None with ThreadPoolExecutor(max_workers=n) as executor: # 记录所有 future 对象以及其对应的 order_no future_map = {executor.submit(worker, order_no): order_no for order_no in order_nos} done, not_done = wait( future_map, return_when=FIRST_EXCEPTION, timeout=10 ) for future in done: result = future.result() if result: results.append(result) for future in not_done: order_no = future_map[future] future.cancel() errors[order_no] = "Request timed out or was cancelled." assert len(errors) == 0, f"Errors occurred during requests: {errors}" assert len([r for r in results if r.get("success") is True]) == 1 说明 Barrier 用于对齐所有线程的起跑线，确保在同一时间点发起请求，模拟高并发场景。 barrier.wait(timeout=5) 会阻塞线程，直到所有线程都到达或超时。 通过 wait(..., return_when=FIRST_EXCEPTION) 可以在发生首个异常后提前结束等待，避免无意义的长时间阻塞。 future_map 用于将 Future 与 order_no 关联，便于定位超时或异常请求。 额外注意 requests 默认的连接池大小为 10。如果并发测试需要更高的连接数，需要手动配置连接池（例如通过 HTTPAdapter(pool_maxsize=...)）以避免连接数成为瓶颈。'><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-02-02T13:28:05+08:00"><meta property="article:modified_time" content="2026-02-02T13:28:05+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="使用 ThreadPoolExecutor 和 Barrier 进行接口并发测试"><meta name=twitter:description content='下面以接口支付并发为例，演示如何通过 ThreadPoolExecutor + Barrier 同步触发请求，并收集结果与错误信息。
示例代码
import threading
from concurrent.futures import FIRST_EXCEPTION, ThreadPoolExecutor, wait
from typing import Any, Optional

import pytest

from api import OrderAPI
from factory import order_pay_payload

class TestOrderPay:

    @pytest.mark.concurrent
    @pytest.mark.parametrize(
        "generator", [{"pay_need": 5, "user_id": 10005, "org_id": 1}], indirect=True
    )
    def test_concurrent_req(self, order_api: OrderAPI, generator: dict):
        """并发支付，确保只有一个请求成功，其余请求失败"""
        order_nos: list = [order["orderNo"] for order in generator["pay_need_orders"]]

        n: int = len(order_nos)
        barrier: threading.Barrier = threading.Barrier(n)

        results: list[dict[str, Any]] = []
        errors: dict[str, str] = {}

        def worker(order_no: str) -> Optional[dict[str, Any]]:
            try:
                barrier.wait(timeout=5)

                data = order_api.pay_order(payload=order_pay_payload(order_no=order_no))

                return {
                    "order_no": order_no,
                    "success": data["success"],
                    "code": data["code"],
                    "message": data["message"],
                }

            except threading.BrokenBarrierError as e:
                errors[order_no] = str(e)
                return None
            except Exception as e:
                errors[order_no] = str(e)
                return None

        with ThreadPoolExecutor(max_workers=n) as executor:
            # 记录所有 future 对象以及其对应的 order_no
            future_map = {executor.submit(worker, order_no): order_no for order_no in order_nos}

            done, not_done = wait(
                future_map, return_when=FIRST_EXCEPTION, timeout=10
            )

            for future in done:
                result = future.result()
                if result:
                    results.append(result)

            for future in not_done:
                order_no = future_map[future]
                future.cancel()
                errors[order_no] = "Request timed out or was cancelled."

        assert len(errors) == 0, f"Errors occurred during requests: {errors}"

        assert len([r for r in results if r.get("success") is True]) == 1
说明

Barrier 用于对齐所有线程的起跑线，确保在同一时间点发起请求，模拟高并发场景。
barrier.wait(timeout=5) 会阻塞线程，直到所有线程都到达或超时。
通过 wait(..., return_when=FIRST_EXCEPTION) 可以在发生首个异常后提前结束等待，避免无意义的长时间阻塞。
future_map 用于将 Future 与 order_no 关联，便于定位超时或异常请求。

额外注意
requests 默认的连接池大小为 10。如果并发测试需要更高的连接数，需要手动配置连接池（例如通过 HTTPAdapter(pool_maxsize=...)）以避免连接数成为瓶颈。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://iuwu98005.github.io/posts/"},{"@type":"ListItem","position":2,"name":"使用 ThreadPoolExecutor 和 Barrier 进行接口并发测试","item":"https://iuwu98005.github.io/posts/26012202/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"使用 ThreadPoolExecutor 和 Barrier 进行接口并发测试","name":"使用 ThreadPoolExecutor 和 Barrier 进行接口并发测试","description":"下面以接口支付并发为例，演示如何通过 ThreadPoolExecutor + Barrier 同步触发请求，并收集结果与错误信息。\n示例代码 import threading from concurrent.futures import FIRST_EXCEPTION, ThreadPoolExecutor, wait from typing import Any, Optional import pytest from api import OrderAPI from factory import order_pay_payload class TestOrderPay: @pytest.mark.concurrent @pytest.mark.parametrize( \u0026#34;generator\u0026#34;, [{\u0026#34;pay_need\u0026#34;: 5, \u0026#34;user_id\u0026#34;: 10005, \u0026#34;org_id\u0026#34;: 1}], indirect=True ) def test_concurrent_req(self, order_api: OrderAPI, generator: dict): \u0026#34;\u0026#34;\u0026#34;并发支付，确保只有一个请求成功，其余请求失败\u0026#34;\u0026#34;\u0026#34; order_nos: list = [order[\u0026#34;orderNo\u0026#34;] for order in generator[\u0026#34;pay_need_orders\u0026#34;]] n: int = len(order_nos) barrier: threading.Barrier = threading.Barrier(n) results: list[dict[str, Any]] = [] errors: dict[str, str] = {} def worker(order_no: str) -\u0026gt; Optional[dict[str, Any]]: try: barrier.wait(timeout=5) data = order_api.pay_order(payload=order_pay_payload(order_no=order_no)) return { \u0026#34;order_no\u0026#34;: order_no, \u0026#34;success\u0026#34;: data[\u0026#34;success\u0026#34;], \u0026#34;code\u0026#34;: data[\u0026#34;code\u0026#34;], \u0026#34;message\u0026#34;: data[\u0026#34;message\u0026#34;], } except threading.BrokenBarrierError as e: errors[order_no] = str(e) return None except Exception as e: errors[order_no] = str(e) return None with ThreadPoolExecutor(max_workers=n) as executor: # 记录所有 future 对象以及其对应的 order_no future_map = {executor.submit(worker, order_no): order_no for order_no in order_nos} done, not_done = wait( future_map, return_when=FIRST_EXCEPTION, timeout=10 ) for future in done: result = future.result() if result: results.append(result) for future in not_done: order_no = future_map[future] future.cancel() errors[order_no] = \u0026#34;Request timed out or was cancelled.\u0026#34; assert len(errors) == 0, f\u0026#34;Errors occurred during requests: {errors}\u0026#34; assert len([r for r in results if r.get(\u0026#34;success\u0026#34;) is True]) == 1 说明 Barrier 用于对齐所有线程的起跑线，确保在同一时间点发起请求，模拟高并发场景。 barrier.wait(timeout=5) 会阻塞线程，直到所有线程都到达或超时。 通过 wait(..., return_when=FIRST_EXCEPTION) 可以在发生首个异常后提前结束等待，避免无意义的长时间阻塞。 future_map 用于将 Future 与 order_no 关联，便于定位超时或异常请求。 额外注意 requests 默认的连接池大小为 10。如果并发测试需要更高的连接数，需要手动配置连接池（例如通过 HTTPAdapter(pool_maxsize=...)）以避免连接数成为瓶颈。\n","keywords":[],"articleBody":"下面以接口支付并发为例，演示如何通过 ThreadPoolExecutor + Barrier 同步触发请求，并收集结果与错误信息。\n示例代码 import threading from concurrent.futures import FIRST_EXCEPTION, ThreadPoolExecutor, wait from typing import Any, Optional import pytest from api import OrderAPI from factory import order_pay_payload class TestOrderPay: @pytest.mark.concurrent @pytest.mark.parametrize( \"generator\", [{\"pay_need\": 5, \"user_id\": 10005, \"org_id\": 1}], indirect=True ) def test_concurrent_req(self, order_api: OrderAPI, generator: dict): \"\"\"并发支付，确保只有一个请求成功，其余请求失败\"\"\" order_nos: list = [order[\"orderNo\"] for order in generator[\"pay_need_orders\"]] n: int = len(order_nos) barrier: threading.Barrier = threading.Barrier(n) results: list[dict[str, Any]] = [] errors: dict[str, str] = {} def worker(order_no: str) -\u003e Optional[dict[str, Any]]: try: barrier.wait(timeout=5) data = order_api.pay_order(payload=order_pay_payload(order_no=order_no)) return { \"order_no\": order_no, \"success\": data[\"success\"], \"code\": data[\"code\"], \"message\": data[\"message\"], } except threading.BrokenBarrierError as e: errors[order_no] = str(e) return None except Exception as e: errors[order_no] = str(e) return None with ThreadPoolExecutor(max_workers=n) as executor: # 记录所有 future 对象以及其对应的 order_no future_map = {executor.submit(worker, order_no): order_no for order_no in order_nos} done, not_done = wait( future_map, return_when=FIRST_EXCEPTION, timeout=10 ) for future in done: result = future.result() if result: results.append(result) for future in not_done: order_no = future_map[future] future.cancel() errors[order_no] = \"Request timed out or was cancelled.\" assert len(errors) == 0, f\"Errors occurred during requests: {errors}\" assert len([r for r in results if r.get(\"success\") is True]) == 1 说明 Barrier 用于对齐所有线程的起跑线，确保在同一时间点发起请求，模拟高并发场景。 barrier.wait(timeout=5) 会阻塞线程，直到所有线程都到达或超时。 通过 wait(..., return_when=FIRST_EXCEPTION) 可以在发生首个异常后提前结束等待，避免无意义的长时间阻塞。 future_map 用于将 Future 与 order_no 关联，便于定位超时或异常请求。 额外注意 requests 默认的连接池大小为 10。如果并发测试需要更高的连接数，需要手动配置连接池（例如通过 HTTPAdapter(pool_maxsize=...)）以避免连接数成为瓶颈。\nrequests 通过 urllib3 实现连接池，默认值来自 urllib3.PoolManager 与 HTTPAdapter 的默认设置（pool_connections=10、pool_maxsize=10）\nThreadPoolExecutor 简介 ThreadPoolExecutor 是 concurrent.futures 提供的线程池实现，适合处理 I/O 密集型任务（例如网络请求）。它通过固定数量的工作线程复用来降低频繁创建线程的开销。常用参数包括：\nmax_workers：线程池大小，通常设置为并发量或略高于 CPU 核心数的倍数（I/O 密集型可适当增大）。 submit()：提交任务并返回 Future，用于获取结果或异常。 shutdown()：优雅关闭线程池（在 with 语句中会自动调用）。 ","wordCount":"233","inLanguage":"en","datePublished":"2026-02-02T13:28:05+08:00","dateModified":"2026-02-02T13:28:05+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://iuwu98005.github.io/posts/26012202/"},"publisher":{"@type":"Organization","name":"My Blog","logo":{"@type":"ImageObject","url":"https://iuwu98005.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://iuwu98005.github.io/ accesskey=h title="My Blog (Alt + H)">My Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://iuwu98005.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://iuwu98005.github.io/projects/ title=Projects><span>Projects</span></a></li><li><a href=https://iuwu98005.github.io/about/ title=About><span>About</span></a></li><li><a href=https://iuwu98005.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://iuwu98005.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://iuwu98005.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">使用 ThreadPoolExecutor 和 Barrier 进行接口并发测试</h1><div class=post-meta><span title='2026-02-02 13:28:05 +0800 +0800'>February 2, 2026</span>&nbsp;·&nbsp;2 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e7%a4%ba%e4%be%8b%e4%bb%a3%e7%a0%81 aria-label=示例代码>示例代码</a></li><li><a href=#%e8%af%b4%e6%98%8e aria-label=说明>说明</a><ul><li><a href=#%e9%a2%9d%e5%a4%96%e6%b3%a8%e6%84%8f aria-label=额外注意>额外注意</a></li></ul></li><li><a href=#threadpoolexecutor-%e7%ae%80%e4%bb%8b aria-label="ThreadPoolExecutor 简介">ThreadPoolExecutor 简介</a></li></ul></div></details></div><div class=post-content><p>下面以接口支付并发为例，演示如何通过 <code>ThreadPoolExecutor</code> + <code>Barrier</code> 同步触发请求，并收集结果与错误信息。</p><h2 id=示例代码>示例代码<a hidden class=anchor aria-hidden=true href=#示例代码>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> threading
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> concurrent.futures <span style=color:#f92672>import</span> FIRST_EXCEPTION, ThreadPoolExecutor, wait
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> typing <span style=color:#f92672>import</span> Any, Optional
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> pytest
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> api <span style=color:#f92672>import</span> OrderAPI
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> factory <span style=color:#f92672>import</span> order_pay_payload
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TestOrderPay</span>:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@pytest.mark.concurrent</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@pytest.mark.parametrize</span>(
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;generator&#34;</span>, [{<span style=color:#e6db74>&#34;pay_need&#34;</span>: <span style=color:#ae81ff>5</span>, <span style=color:#e6db74>&#34;user_id&#34;</span>: <span style=color:#ae81ff>10005</span>, <span style=color:#e6db74>&#34;org_id&#34;</span>: <span style=color:#ae81ff>1</span>}], indirect<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>test_concurrent_req</span>(self, order_api: OrderAPI, generator: dict):
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;&#34;&#34;并发支付，确保只有一个请求成功，其余请求失败&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        order_nos: list <span style=color:#f92672>=</span> [order[<span style=color:#e6db74>&#34;orderNo&#34;</span>] <span style=color:#66d9ef>for</span> order <span style=color:#f92672>in</span> generator[<span style=color:#e6db74>&#34;pay_need_orders&#34;</span>]]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        n: int <span style=color:#f92672>=</span> len(order_nos)
</span></span><span style=display:flex><span>        barrier: threading<span style=color:#f92672>.</span>Barrier <span style=color:#f92672>=</span> threading<span style=color:#f92672>.</span>Barrier(n)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        results: list[dict[str, Any]] <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>        errors: dict[str, str] <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>worker</span>(order_no: str) <span style=color:#f92672>-&gt;</span> Optional[dict[str, Any]]:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>                barrier<span style=color:#f92672>.</span>wait(timeout<span style=color:#f92672>=</span><span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                data <span style=color:#f92672>=</span> order_api<span style=color:#f92672>.</span>pay_order(payload<span style=color:#f92672>=</span>order_pay_payload(order_no<span style=color:#f92672>=</span>order_no))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> {
</span></span><span style=display:flex><span>                    <span style=color:#e6db74>&#34;order_no&#34;</span>: order_no,
</span></span><span style=display:flex><span>                    <span style=color:#e6db74>&#34;success&#34;</span>: data[<span style=color:#e6db74>&#34;success&#34;</span>],
</span></span><span style=display:flex><span>                    <span style=color:#e6db74>&#34;code&#34;</span>: data[<span style=color:#e6db74>&#34;code&#34;</span>],
</span></span><span style=display:flex><span>                    <span style=color:#e6db74>&#34;message&#34;</span>: data[<span style=color:#e6db74>&#34;message&#34;</span>],
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>except</span> threading<span style=color:#f92672>.</span>BrokenBarrierError <span style=color:#66d9ef>as</span> e:
</span></span><span style=display:flex><span>                errors[order_no] <span style=color:#f92672>=</span> str(e)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>Exception</span> <span style=color:#66d9ef>as</span> e:
</span></span><span style=display:flex><span>                errors[order_no] <span style=color:#f92672>=</span> str(e)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>with</span> ThreadPoolExecutor(max_workers<span style=color:#f92672>=</span>n) <span style=color:#66d9ef>as</span> executor:
</span></span><span style=display:flex><span>            <span style=color:#75715e># 记录所有 future 对象以及其对应的 order_no</span>
</span></span><span style=display:flex><span>            future_map <span style=color:#f92672>=</span> {executor<span style=color:#f92672>.</span>submit(worker, order_no): order_no <span style=color:#66d9ef>for</span> order_no <span style=color:#f92672>in</span> order_nos}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            done, not_done <span style=color:#f92672>=</span> wait(
</span></span><span style=display:flex><span>                future_map, return_when<span style=color:#f92672>=</span>FIRST_EXCEPTION, timeout<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> future <span style=color:#f92672>in</span> done:
</span></span><span style=display:flex><span>                result <span style=color:#f92672>=</span> future<span style=color:#f92672>.</span>result()
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> result:
</span></span><span style=display:flex><span>                    results<span style=color:#f92672>.</span>append(result)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> future <span style=color:#f92672>in</span> not_done:
</span></span><span style=display:flex><span>                order_no <span style=color:#f92672>=</span> future_map[future]
</span></span><span style=display:flex><span>                future<span style=color:#f92672>.</span>cancel()
</span></span><span style=display:flex><span>                errors[order_no] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Request timed out or was cancelled.&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>assert</span> len(errors) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Errors occurred during requests: </span><span style=color:#e6db74>{</span>errors<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>assert</span> len([r <span style=color:#66d9ef>for</span> r <span style=color:#f92672>in</span> results <span style=color:#66d9ef>if</span> r<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;success&#34;</span>) <span style=color:#f92672>is</span> <span style=color:#66d9ef>True</span>]) <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><h2 id=说明>说明<a hidden class=anchor aria-hidden=true href=#说明>#</a></h2><ul><li><code>Barrier</code> 用于对齐所有线程的起跑线，确保在同一时间点发起请求，模拟高并发场景。</li><li><code>barrier.wait(timeout=5)</code> 会阻塞线程，直到所有线程都到达或超时。</li><li>通过 <code>wait(..., return_when=FIRST_EXCEPTION)</code> 可以在发生首个异常后提前结束等待，避免无意义的长时间阻塞。</li><li><code>future_map</code> 用于将 <code>Future</code> 与 <code>order_no</code> 关联，便于定位超时或异常请求。</li></ul><h3 id=额外注意>额外注意<a hidden class=anchor aria-hidden=true href=#额外注意>#</a></h3><p><code>requests</code> 默认的连接池大小为 10。如果并发测试需要更高的连接数，需要手动配置连接池（例如通过 <code>HTTPAdapter(pool_maxsize=...)</code>）以避免连接数成为瓶颈。</p><p><code>requests</code> 通过 <code>urllib3</code> 实现连接池，默认值来自 <code>urllib3.PoolManager</code> 与 <code>HTTPAdapter</code> 的默认设置<code>（pool_connections=10、pool_maxsize=10）</code></p><h2 id=threadpoolexecutor-简介>ThreadPoolExecutor 简介<a hidden class=anchor aria-hidden=true href=#threadpoolexecutor-简介>#</a></h2><p><code>ThreadPoolExecutor</code> 是 <code>concurrent.futures</code> 提供的线程池实现，适合处理 I/O 密集型任务（例如网络请求）。它通过固定数量的工作线程复用来降低频繁创建线程的开销。常用参数包括：</p><ul><li><code>max_workers</code>：线程池大小，通常设置为并发量或略高于 CPU 核心数的倍数（I/O 密集型可适当增大）。</li><li><code>submit()</code>：提交任务并返回 <code>Future</code>，用于获取结果或异常。</li><li><code>shutdown()</code>：优雅关闭线程池（在 <code>with</code> 语句中会自动调用）。</li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://iuwu98005.github.io/posts/260122-gemini/><span class=title>Next »</span><br><span>配置 Clash 分流规则以使用 Gemini</span></a></nav></footer></article></main><footer class=footer><span>© 2025 IUWU98005</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>